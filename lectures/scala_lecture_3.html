<!doctype html>
<html lang="ru">

<head>
    <meta charset="utf-8">

    <title>Система типов в Scala</title>

    <meta name="description" content="Система типов в Scala">
    <meta name="author" content="Соколов Артём">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/white.css" id="theme">

    <link rel="stylesheet" href="css/hljs/vs.css" id="highlight-theme">

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->

    <link rel="stylesheet" href="css/custom.css">
</head>

<body>
    <div class="reveal lecture3">
        <div class="footer">
            <span class="corp-name"><b>NAUMEN </b></span>Соколов Артём
        </div>

        <div class="slides">
            <section>
                <h1>Система типов в Scala</h1>
                <div style="position: relative; right: 0;">Соколов Артём</div>
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Что такое тип?</h1>
                    <p class="left">Scala:
                        <pre><code data-trim data-noescape>
                            val x: Int = 1
                        </code></pre>
                    </p>
                    <p class="left">Java:
                        <pre><code data-trim data-noescape class="java">
                            Integer x = 1;
                        </code></pre
                        ></p>
                    <p class="left">C#:
                        <pre><code data-trim data-noescape class="cs">
                            int i = 1;
                        </code></pre>
                    </p>
            </section>
        </div>
        <div class="slides">
                <section>
                    <h1>Типы в языках</h1>
                    <p>Тип это некоторое ограничение, 
                        накладываемое на какое-то значение и на то как это значение может использоваться.</p>
                    <pre><code class="scala" data-noescape>
val a: Int = 1

a > 1

a = false

val b: Boolean = false

b || true

b > 1

b.someMethod()
                    </code></pre>
            </section>
        </div>
        <div class="slides">
                <section>
                    <h1>Система типов</h1>
                    <p>
                        Система типов в языке - это набор базовых типов, правила и механизмы по описанию новых типов и по применению различных типов.
                    </p>
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Виды систем типов</h1>
                <ul>
                    <li>Время проверки правил
                        <ul>
                            <li>Статические</li>
                            <li>Динамические</li>
                        </ul>
                    </li>
                    <li>Строгость правил
                        <ul>
                            <li>Статические</li>
                            <li>Динамические</li>
                        </ul>
                    </li>
                </ul>
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Виды систем типов</h1>
                <img src="img/lecture_3/strongweakstaticdynamic_type.png"/>
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Виды систем типов</h1><h4>Статическая/динамическая типизация</h4>
                <ul>
                    <li>Статические - те которые осуществляют проверку типов во время компиляции.
                        <p>Примеры: Java, C#, TypeScript, C/C++, Rust, Scala и др.</p></li>
                    <li>Динамические - те которые проверяют непосредственно при работе программы. 
                        <p>Примеры: JavaScript, Python, PHP, Ruby, Perl, Clojure и др.</p></li>
                </ul>
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Виды систем типов</h1><h4>Статическая/динамическая типизация</h4>
                <li>Деление довольно условно</li>
                <li>Статические языки зачастую имеют возможность использовать динамическую типизацию 
                    <p>(scala.Dynamic)</p>
                </li>
                <li>Динамические - прикручивают поверх себя инструменты проводящие статическую проверку кода, в том числе типов
                    <p>(JavaScript - Flow, Python - PEP 484 introduced type hints)</p>
                </li>
                <li>Отличие в том что закладывалось изначально в язык</li>
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Виды систем типов</h1><h4>Слабая/сильная типизация</h4>
                <li>Еще более условное деление</li>
                <li>Определяется тем насколько язык склонен делать допущения при проверке типов</li>
                <li>На слабо типизированных языках проще писать (не надо бороться с системой типов)</li>
                <li>Однако сложнее писать корректные и безопасные программы</li>
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Виды систем типов</h1>
                <h4>Что лучше..?</h4>
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Виды систем типов</h1><h4>Что лучше?</h4>
                <p><b>Большинство программистов</b> считают что в <b>большинстве случаев</b> лучше язык со статической и строгой типизацией <b>при разработке программ</b></p>
                <p>Ниша динамических и/или слабо типизированных языков - небольших и простые приложения (скрипты, примитивные приложения, обучение) </p>
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Виды систем типов</h1>
                <h4>Статическая строгая типизация</h4>
                <p>Проблемы для языка:</p>
                <li>Сложный компилятор (дорого, багоемко, неповоротливо)</li>
                <li>Долгая компиляция</li>
                <p>Проблемы для разработчика:</p>
                <li>Нужно описывать типы</li>
                <li>Сложнее использовать</li>
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Виды систем типов</h1>
                <h4>Статическая строгая типизация</h4>
                <p>Решение проблем разработчиков в Scala:</p>
                <li>Вывод типов чтобы их писать по минимуму</li>
                <li>Мощная система типов позволяющая использовать типы легко
                    <p class="fragment">(однако создателям библиотек приходиться попотеть) </p>
                    <p class="fragment">((также как и создателям языка)) </p>
                </li>
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Система типов в Scala</h1>
                <img style="height: auto;" src="img/lecture_3/scala-logo.png">
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Система типов в Scala</h1>
                <h4>Вывод типов</h4>
                <p>По простому - там где типы могут быть однозначно просчитаны компилятором - их можно не писать</p>
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Система типов в Scala</h1>
                <h4>Вывод типов</h4>
                <p class="left">Пример:</p>
                <pre><code class="scala">
val x = "Hello world" // val x: String

def someFunction() = 42 // def someFunction(): Int

val y = {
    if(randomBoolean) {
        Cat // наследует Animal
    } else {
        Dog // наследует Animal
    }
} 
// val y: Animal
                </code></pre>
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Система типов в Scala</h1>
                <p>Гибко и удобно использовать систему типов позволяет полиморфизм</p>
                <h4>Что такое полиморфизм..?</h4>
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Система типов в Scala</h1><h3>Полиморфизм</h3>
                <p>Принципиальная возможность для одного и того же кода обрабатывать данные разных типов</p>
                <p>Зачастую ставятся определенные условия, которым должны соответствовать типы</p>
                <p>В каждом конкретном языке - набор отдельных фич которые дают ту или иную степерь полиморфизма</p>
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Полиморфизм</h1><h3>Виды</h3>
                <li>полиморфизм подтипов <p>(subtyping | наследование)</p></li>
                <li>параметрический полиморфизм <p>(generics)</p></li>
                <li>ad-hoc полиморфизм<p>(перегрузка функций/операторов, 
                        авто приведение типов Int -> Long, 
                        в scala - implicit conversion, pattern typeclass)</p></li>
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Полиморфизм подтипов</h1>
                <li>Полифморфизм подтипов - наиболее простой и распространенный</li>
                <li>Определены базовые правила работы подтипов</li>
                <li>Новые типы задаются через определение новых class/trait</li>
                <li>Отношения задаются в основном через наследование</li>
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Полиморфизм подтипов</h1>
                <li>Буква L в SOLID</li>
                <li>Liskov Substitution Principle (Принцип подстановки Барбары Лисков)</li>
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Полиморфизм подтипов</h1><h3>Liskov Substitution Principle</h3>
                <pre><code class="scala">

// для обозначения подтипа в Scala используется "<:"
// Subtype <: Supertype

class Animal

class Cat extends Animal 
// Cat <: Animal 

class Dog extends Animal 
// Dog <: Animal

def foo(x: Animal) = ???

foo(new Cat()) // OK if Cat <: Animal

foo(new Dog()) // OK if Dog <: Animal

foo("Hello world") // compile error
                </code></pre>

            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Полиморфизм подтипов</h1><h3>Liskov Substitution Principle</h3>
                Формально: 
                <p>если для некоторого типа A выполняется какое-то правило</p> <p><span>foo(A.value) == OK</span></p>
                <p>то тогда для любого типа B, являющегося подтипом типа A </p>
                    <p>B <: A</p>
                    <p>также должно выполняться это правило</p>
                    <p>foo(B.value) == OK</p>
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Полиморфизм подтипов</h1><h3>Иерархия</h3>
                <img src="img/lecture_3/class-hierarchy-of-scala.png">
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Полиморфизм подтипов</h1>
                <p>Any - надтип (supertype) всех типов в Scala</p>
                <p class="left">Использование:</p>
                <pre><code>
def foo(x: Any) = ???

val a = if (randomBoolean) {
            "Hello world"
        } else {
            42
        }
        
// val a: Any - Почему..?
                </code></pre>
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Полиморфизм подтипов</h1>
                <p>AnyVal - тип оберток над значениями</p>
                <p>Компилятор с такими типами обходится по особенному - стремится оптимизировать так чтобы обертка не создавала реальный объект в памяти</p>
                Использование:
                <li>примитивы - Int, Long, Double, и т.д.</li>
                <li>Обертки добавляющие методы или дополнительный тип</li>
                <li>Unit</li>
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Полиморфизм подтипов</h1><h3>Unit</h3>
                <li>Тип с единственным значением "()"</li>
                <li>Используется в местах где в C#/Java стоял бы "void"</li>
                <li>Т.е. тогда, когда нам не интересно значение выполнения функции, но нужно какое-то пустое значение</li>
                <li>Обычно связано с сайд-эффектами (печать в консоль, запись в базу, мутацию какого-то внешнего объекта, и т.д.)</li>
                <li>Значения "()" не существует во время исполнения (абстракция на уровне компилятора)</li>
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Полиморфизм подтипов</h1><h3>Переходим к AnyRef</h3>
                <img src="img/lecture_3/class-hierarchy-of-scala.png">
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Полиморфизм подтипов</h1>
                <p>AnyRef - надтип для всех остальных типов данных, т.е. для всех <b>ссылочных типов</b>.</p>
                <li>В jvm - соответствует java.lang.Object, т.е. объектам в heap</li>
                <p>Использование:</p>
                <li>В практике особо не используется</li>
                <li>Но для полноты системы типов нужен</li>
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Полиморфизм подтипов</h1>
                <p>Null - подтип для всех подтипов AnyRef.</p>
                <p>Т.е. для любого X <: AnyRef справедливо Null <: X</p>
                <p>Это делается автоматически на уровне компилятора</p>
                <li>литерал null имеет этот тип</li>
                <li>из-за того что Null это подтип любого подтипа AnyRef - мы можем в любое место которое принимает любой ссылочный тип - поставить null</li>
                <li>также это позволяет работать системе вывода типов при проставлении null</li>
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Полиморфизм подтипов</h1>
                <p>Null</p>
                <pre><code>
val a = if (randomBoolean) {
    "Hello world" // String
} else {
    null // Null
}

// val a: String - потому что Null <: String                
                </code></pre>
                
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Полиморфизм подтипов</h1>
                <li>Nothing - подтип всех типов, также называемый bottom type.</p>
                <li>Т.е. для любого X справедливо Nothing <: X</li>
                <li>Тип у которого нет значениний</li>
                <li>Нужен для полноты системы типов</li>
                <li>В некоторых случаях удобно использовать в качестве подтипа любого типа</li>
                <li>Выражение в результате которого выбрасывается exception имеет тип Nothing
                    (частный случай - "???")
                </li>
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Полиморфизм подтипов</h1>
                <p>Nothing</p>
                <pre><code>
val a = if (randomBoolean) {
    42 // Int
} else {
    ??? // Nothing
}

// val a: Int - потому что Nothing <: Int                
                </code></pre>
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Полиморфизм подтипов</h1>
                <h3>Подведем итоги</h3>
                <img src="img/lecture_3/class-hierarchy-of-scala.png">
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Полиморфизм подтипов</h1>
                <p>Полиморфизм подтипов (subtyping) - имеет пересечения и взаимодействие с другими видами полиморфизма.</p>
                <p>Точнее ряд фич системы типов Scala, которые относятся к полиморфизмам другого типа, учитывают правила которые справедливы для подтипов</p>
            </section>
        </div>

        <div class="slides">
            <section>
                <h1>Парам. полиморфизм</h1>
                <li>Второй по распространенности и используемости вид полиморфизма</li>
                <li>Его вы скорее всего знаете в виде дженериков и параметров типов при объявлении классов и методов</li>
                <pre><code class="scala">
def someMethod[T](x: T) = ???

class List[A] {
    def add(a: A) = ???
}
                </code></pre>
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Парам. полиморфизм</h1>
                <h4>является ли List[A] - типом?</h4>
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Парам. полиморфизм</h1>
                <h4>является ли List[A] типом? - Нет</h4>
                <p>Нельзя задать переменную с типом List[A]:</p>
                <pre><code>
        val x: List[A] // compile error
                        </code></pre>
                <p>Можно задать переменную с типом, сконструированным с помощью дженерика:6</p>
                <pre><code>
        val x: List[Int] // OK - тип списка интов
                </code></pre>
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Парам. полиморфизм</h1>
                <p>List[A] - задает как бы семейство или множество типов различных типов</p>
                <p>Можно на дженерик также смотреть как на конструктор типа</p>
                <p>допустим у нас есть некий тип X и мы с помощью такого конструктора List[_] можем сконструировать тип List[X]</p>
                <p>Пример: берем тип Int, берем конструктор типа List[_] - конструируем конкретный тип List[Int]</p>
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Парам. полиморфизм</h1>
                <h3>Где в иерархии подтипов находятся List[A] ?</h3>
                <img src="img/lecture_3/class-hierarchy-of-scala.png">
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Парам. полиморфизм</h1>
                <h3>Имеют ли между собой отношения подтипов разные типы семейства типов List[A]?</h3>
                <pre><code>
// если Int <: Any то можно ли сказать что List[Int] <: List[Any]

val x: List[Int] 

val a: List[Any] = x // OK?
                </code></pre>
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Парам. полиморфизм</h1>
                <h3>Имеют ли между собой отношения подтипов разные типы семейства типов List[A]?</h3>
                <h3>Нет</h3>
                <img src="img/lecture_3/invarianceDList.png" />
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Парам. полиморфизм</h1>
                <p>Подобные отношения среди типов одного семейства называются вариантностью</p>
                <li>Инвариантный (invariant) дженерик - по умолчанию</li>
                <li>Ковариантный (covariance) - Producer[+A]</li>
                <li>Контравариантный (contravariance) - Consumer[-A]</li>
            </section>
        </div>
        <div class="slides">
            <section>
                <h1>Парам. полиморфизм</h1>
                <p>Ковариантный (covariance) - Producer[+A]</p>
                <img src="img/lecture_3/covarianceDList.PNG" />
            </section>
        </div>
        <div class="slides">
            <section>
                    <h1>Парам. полиморфизм</h1>
                <p>Контравариантный (contravariance) - Consumer[-A]</p>
                <img src="img/lecture_3/contravarianceDList.PNG" />
            </section>
        </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

        // Full list of configuration options available at:
        // https://github.com/hakimel/reveal.js#configuration
        Reveal.initialize({
            controls: false,
            progress: true,
            history: true,
            center: true,
            slideNumber: true,

            transition: 'slide', // none/fade/slide/convex/concave/zoom

            // Optional reveal.js plugins
            dependencies: [
                {
                    src: 'lib/js/classList.js', condition: function () {
                        return !document.body.classList;
                    }
                },
                {
                    src: 'plugin/markdown/marked.js', condition: function () {
                        return !!document.querySelector('[data-markdown]');
                    }
                },
                {
                    src: 'plugin/markdown/markdown.js', condition: function () {
                        return !!document.querySelector('[data-markdown]');
                    }
                },
                {
                    src: 'plugin/highlight/highlight.js', async: true, condition: function () {
                        return !!document.querySelector('pre code');
                    }, callback: function () {
                        hljs.initHighlightingOnLoad();
                    }
                },
                { src: 'plugin/zoom-js/zoom.js', async: true },
                { src: 'plugin/notes/notes.js', async: true }
            ]
        });

        window.addEventListener("mousedown", handleClick, false);
        window.addEventListener("contextmenu", function (e) {
            e.preventDefault();
        }, false);

        function handleClick(e) {
            e.preventDefault();
            if (e.button === 0) Reveal.next();
            if (e.button === 2) Reveal.prev();
        }
    </script>

</body>

</html>